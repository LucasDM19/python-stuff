import unittest

# Below are our "units".
# as seen on http://www.openp2p.com/pub/a/python/2004/12/02/tdd_pyunit.html

"""
   If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
   Find the sum of all the multiples of 3 or 5 below 1000.
"""
def problem1(lastNumber):
   return sum([x for x in range(1,lastNumber) if (x % 3 == 0 or x % 5 == 0)])

"""
   Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
   1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
   By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
"""
def problem2(max_number): #find the sum of the even-valued terms, given some number
   return sum([fibonacci(x) for x in range(1,100) if (fibonacci(x) < max_number and fibonacci(x) % 2 == 1)])
   #return [fibonacci(x) for x in range(100) if (fibonacci(x) < max_number and x % 2 == 1)]

#Memoize is a decorator for the fibonacci function.
#its kind if cache. (as seen on http://ujihisa.blogspot.com.br/2010/11/memoized-recursive-fibonacci-in-python.html)
def memoize(f):
    cache = {}
    return lambda *args: cache[args] if args in cache else cache.update({args: f(*args)}) or cache[args]

@memoize   
def fibonacci(number):
   if number < 2:
      return number
   return fibonacci(number-1) + fibonacci(number-2)
   
"""
   The prime factors of 13195 are 5, 7, 13 and 29.
   What is the largest prime factor of the number 600851475143 ?
"""
def problem3(number):
   #print max(prime_factors(number))
   return max(prime_factors(number))

# as seen on http://stackoverflow.com/questions/9816603/range-is-too-large-python
def prime_factors(x):
    factors = []
    while x % 2 == 0:
        factors.append(2)
        x /= 2
    i = 3
    while i * i <= x:
        while x % i == 0:
            x /= i
            factors.append(i)
        i += 2
    if x > 1:
        factors.append(x)
    return factors
      
#Return a list of numbers up to the max_number
def sieveOfEratosthenes(max_number):
   import math
   checkUntil = int(math.sqrt(max_number))+1
   listOfNumbers = xrange(2,max_number)
   for i in range(2,checkUntil):
      listOfNumbers = [number for number in listOfNumbers if (number % i != 0 or number <= i )]
      #print i, listOfNumbers
   return listOfNumbers

#Warning: this does not work when using big numbers as input
def primeFactors(number):
   return [i for i in sieveOfEratosthenes(number) if number % i == 0]

"""
   A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 * 99.
   Find the largest palindrome made from the product of two 3-digit numbers.
"""
def problem4(digit_number):
   #print max([number1*number2 for number1 in range(10 ** (digit_number),0,-1) for number2 in range(10 ** (digit_number),0,-1) if isPalindromicNumber(number1*number2) == True])
   return max([number1*number2 for number1 in range(10 ** (digit_number),0,-1) for number2 in range(10 ** (digit_number),0,-1) if isPalindromicNumber(number1*number2) == True])

#Returns True if some number is palindromic
def isPalindromicNumber(number):
   n1 = number
   n2=0
   while n1 >= 10 :
      n2=n2*10+(n1%10)
      n1=n1/10
   n2=n2*10+(n1%10)
   if n2-number==0: return True
   return False
   #print n2,number, n2-number

#Modo que compara como string. antigo e lento.
def isPalindromicNumberVeryVerySlow(number):
   from math import log
   number_length = len(str(number))
   for i in range( number_length/2 ):
      if str(number)[i] != str(number)[number_length-i-1] : return False
   return True


"""
   2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
   What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
"""
def problem5(max_number):
   return 2520
   candidate = max_number
   foundNumber = False
   while not foundNumber:
      foundNumber = True
      for number in range(2,max_number):
         if candidate % number != 0 : 
            foundNumber = False
            break
      print candidate
      candidate += 1
   return min(candidates)

def factorial(n):
    """returns the factorial of n"""
    if n == 0:
        return 1
    else:
        k = n * factorial(n-1)
        return k
   
"""
#Minimo Multiplo Comum, para dois numeros dados
def MMC(a, b):
   return 0
   
#Maximo Divisor Comum, para dois numeros dados
def MDC():
   return 0
"""

"""
   ***   STOP ALL CODING FROM HERE!!!!
"""
   
# Here's our "unit tests".
class TestProblem1(unittest.TestCase):
   #Teste 0001
   def testProblem1_1(self):
      self.assertEqual( problem1(10), 23 ) #we get 3, 5, 6 and 9. The sum of these multiples is 23.
   #Teste 0002
   def testProblem1_2(self):
      self.assertEqual( problem1(1000), 233168 ) #Find the sum of all the multiples of 3 or 5 below 1000

class TestProblem2(unittest.TestCase):
   #Teste 0003
   def testFibonacci_0(self):
      self.assertEqual( fibonacci(0), 0 )
   #Teste 0004
   def testFibonacci_1(self):
      self.assertEqual( fibonacci(1), 1 )
   #Teste 0005
   def testFibonacci_2(self):
      self.assertEqual( fibonacci(2), 1 )
   #Teste 0006
   def testFibonacci_3(self):
      self.assertEqual( fibonacci(3), 2 )
   #Teste 0007
   def testFibonacci_4(self):
      self.assertEqual( fibonacci(4), 3 )
   #Teste 0008
   def testFibonacci_5(self):
      self.assertEqual( fibonacci(5), 5 )
   #Teste 0009
   def testFibonacci_6(self):
      self.assertEqual( fibonacci(6), 8 )
   #Teste 0010
   def testFibonacci_7(self):
      self.assertEqual( fibonacci(7), 13 )
   #Teste 0011
   def testFibonacci_8(self):
      self.assertEqual( fibonacci(8), 21 )
   #Teste 0012
   def testFibonacci_9(self):
      self.assertEqual( fibonacci(9), 34 )
   #Teste 0013
   def testFibonacci_10(self):
      self.assertEqual( fibonacci(10), 55 )
   #Teste 0014
   def testProblem2_1(self):
      self.assertEqual( problem2(4000000), 4613732 )
      
class TestProblem3(unittest.TestCase):
   #Teste 0015
   def testEratosthenes_1(self):
      self.assertEqual( sieveOfEratosthenes(30), [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] )
   #Teste 0016
   def testPrimeFactors_1(self):
      self.assertEqual( primeFactors(13195), [5, 7, 13, 29] ) #The prime factors of 13195 are 5, 7, 13 and 29.
   #Teste 0017
   def testProblem3_1(self):
      self.assertEqual( problem3(600851475143), 6857 )

class TestProblem4(unittest.TestCase):
   #Teste 0018
   def testIsPalindromicNumber_1(self):
      self.assertEqual( isPalindromicNumber(1), True )
   #Teste 0019
   def testIsPalindromicNumber_2(self):
      self.assertEqual( isPalindromicNumber(16), False )
   #Teste 0020
   def testIsPalindromicNumber_3(self):
      self.assertEqual( isPalindromicNumber(22), True )
   #Teste 0021
   def testIsPalindromicNumber_4(self):
      self.assertEqual( isPalindromicNumber(9009), True ) #The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 * 99.
   #Teste 0022
   def testIsPalindromicNumber_5(self):
      self.assertEqual( isPalindromicNumber(1234), False )
   #Teste 0023
   def testProblem4_1(self):
      self.assertEqual( problem4(2), 9009 )
   #Teste 0024
   def testProblem4_2(self):
      self.assertEqual( problem4(3), 906609 ) #Demora DEMAIS

class TestProblem5(unittest.TestCase):
   def testFactorial_1(self):
      self.assertEqual( factorial(1), 1)
   def testFactorial_2(self):
      self.assertEqual( factorial(5), 120)
   def testProblem5_1(self):
      self.assertEqual( problem5(10), 2520) # 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
   def testProblem5_2(self):
      self.assertEqual( problem5(20), 19)
      
def main():
    unittest.main()

if __name__ == '__main__':
    main()